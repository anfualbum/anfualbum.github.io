[{"title":"安福相册--使用手册","date":"2017-04-08T02:00:00.000Z","path":"2017/04/08/安福相册--使用手册/","text":"安福相册–使用手册 一、简介。 如果你不想看，可以直接跳过这部分，去看下面的使用手册。 安福相册，安福卖家必备利器！本应用提供档口图片浏览、图片一键下载、分享朋友圈/微博、搜索商品/档口等功能。你可以以游客身份来使用这个工具，也可以通过邮箱注册用户后，登录使用。如果你注册了用户，你就可以收藏自己喜欢的或常用的档口，以便更好地使用此工具，当然以后可能还会有更好的功能供你使用，只要你喜欢，请大胆提出你的意见，我也希望把这款产品做得更好。 如果你看到这份手册，那么这个图你应该看得懂。 身为安福卖家，你一定知道这个网站： www.0594666.com 。 随便找一个点击去后可以看到档口的信息： 这个网址是我们要看图的网站，也是使用我们这个APP时需要的信息： 二、使用手册下面我们来看看这个工具怎么用。 首先，你可以通过手机浏览器登录官网 anfualbum.bmob.site ，如图，点击 [ Android ] 图标(白底黑字)下载并安装。 安装好APP后就可以正常注册了，（当然，你也可以以游客身份使用APP，这样会有很多功能没法用），激活账号后就可以登录使用了。 进入APP后，首先可以看到的是下面这个页面： 和 http://v.yupoo.com/photos/laocaixw/albums/ 对比之后，你应该很容易发现，其实就是图片网站上的东西（如果你下载过那些图片，应该这个网站很熟悉）： 当然，你可以点击下面这个按钮，通过改变网址来查看不同档口的图片，这里的网址，就是上面第一节最后面我们提到的网址。 那么，接下来你就可以尽情的使用它了。 下载在浏览图片的页面：你可以直接点击右下角的下载图标，来下载这个相册的所有图片；你也可以长按图片来选择你需要的图片，然后再下载。 删除在本地查看图片时，类似的：你可以直接点击右下角的删除图标，来删除这个相册的所有图片；你也可以长按图片来选择你要删除的图片，然后再删除。 分享无论在’店铺浏览’页或者’本地查看’页，当你长按图片后，可以发现右下角出现分享字样，你应该看出来了，你可以将选中的图片分享到朋友圈、微博、微信、QQ等，只要你能看到的，你都可以去尝试。 收藏有些人可能觉得每次都要输入网址很麻烦，细心的人应该发现左下角的心型图标了，如果你觉得这个图片网址是你常用的，那么你可以点击这里收藏这个网址（空心代表没收藏，实心代表已收藏）。在 设置 -&gt; 收藏管理 中，可以看到你的收藏网址，你可以点击来跳转页面。 推荐有些人可能没有常用的店铺，会通过安福家园 www.0594666.com 来找自己需要的档口，请注意看，右侧功能菜单拉出后，有安福家园字样，在这里我们可以看到这个网站。当你在这个APP里浏览这个网站时，只要你进入的相册页，APP就会提醒你是否需要跳转到我们的店铺浏览页，以方便你查看图片。 当然，这个APP也有自带推荐项目，那就是发现推荐页，以后我们会慢慢完善这里，如果你有好的档口，你也可以通过建议发给我们，我们会收集大家喜欢的店铺，然后推荐给用户们。 搜索搜索功能在我们APP主页的右上角，放大镜图标，搜索方式有两种，一种是产品，一种是店铺，你可以点击输入框左侧的下拉菜单来选择。 建议你可以通过这个APP直接给我们提建议， 设置 -&gt; 关于作者 -&gt; 建议反馈 ，在这里，你可以畅所欲言，我们会及时采纳。 三、最后更多功能，尽情期待！ 你可以随时联系我，只要有时间，我会及时给你答疑，当然也会虚心接受你的意见： 邮箱：laocaixw@163.com QQ：787246883","tags":[{"name":"安福相册","slug":"安福相册","permalink":"http://laocaixw.github.io/tags/安福相册/"}]},{"title":"Eclipse工程转Android Studio工程","date":"2017-02-28T08:40:00.000Z","path":"2017/02/28/Eclipse工程转Android Studio工程/","text":"Eclipse工程转Android Studio工程（兼容模式）。转载请声明出处。 目前，用Android Studio来开发Android项目已是大势所趋，就连Google也已经宣布了不再支持Eclipse。所以一些老的Eclipse工程转Android Studio工程也是有必要的。工程转换有两种：一种是兼容模式，即Eclipse和Android Studio都可以用的工程结构；一种是Android Studio的目录结构。这里先记录下兼容模式的转换方法。 一.从Eclipse中导出Gradle文件首先保证Eclipse包含Gradle插件，选择菜单File-&gt;Export-&gt;Generate Gradle build files， 然后一路无脑next，勾选需要转换的工程（如果有依赖工程，把依赖工程也勾选上），在finish之前最好勾选上Force overriding of existing files，以保证覆盖掉工程中由于之前有过类似操作而存在的文件。 二.修改gradle文件参数现在，工程中多出了几个gradle相关的文件。修改两个地方为最新版本： 1.build.gradle。 找到 1classpath 'com.android.tools.build:gradle:0.8.+' 改为 1classpath 'com.android.tools.build:gradle:2.2.3'（目前最高版本） 2.gradle/wrapper/gradle-wrapper.properties。 找到 1distributionUrl=http\\://services.gradle.org/distributions/gradle-1.10-all.zip 改为 1distributionUrl=http\\://services.gradle.org/distributions/gradle-2.14.1-all.zip（目前最高版本） 三.导入Android Studio在Android Studio的Welcome界面选择import project（Eclipse ADT,Gradle,etc） 选择工程，等待编译完成。这时候，不会马上编译成功，需要耐心，根据编译错误信息修改错误。常见的错误有：jni库位置、构建工具版本低、图片检查报错、Manifest冲突、jar包冲突等。 四.常见编译错误解决方法1.jni库位置。在build.gradle中添加： 1234sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; 2.构建工具版本低。提高构建工具版本，一般Android Studio都会有提示。 3.图片检查报错。把.9图片放到dawable文件夹而不是mipmap文件夹；在build.gradle中添加： 1234aaptOptions &#123; cruncherEnabled false useNewCruncher false&#125; 4.Manifest冲突。删除重复的uses-permission权限；忽略Manifest资源值冲突： 在manifest根标签上加入: 1xmlns:tools=\"http://schemas.android.com/tools\" 然后，在application标签下添加: 1tools:replace=\"android:icon, android:theme\"（多个属性用,隔开） 或者直接在gradle中添加： 1useOldManifestMerger true 5.jar包冲突。删除library工程中与主工程冲突的jar包。 五.库工程（Library）打aar包如果工程中有依赖工程（即Library工程，Android Studio中称Module工程），那么最好将它打成aar包，以提高日常调试时的编译速度。因为Android Studio每次编译的时候，都会把项目下的所有工程都编译一遍，这样会浪费一些不必要的时间。所以，如果不是特殊情况，最好将Module工程打成aar包来使用。那这个aar怎么生成呢？ 首先，当我们做完前面的操作，程序都正常跑起来了之后。 在Module工程的\\build\\outputs\\aar\\下可以找到编译生成的aar包，把aar包拷到主工程的\\libs\\下。 去掉根目录下settings.gradle文件中原来工程的include： 1// include ':XXXXX' 将主工程中build.gradle文件的工程依赖关系，改为aar包依赖： 12// compile project(':XXXXX')compile(name: 'XXXXX', ext: 'aar') 点击右上角Sync Now，等待gradle完成，这样就OK了，是不是很简单！","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://laocaixw.github.io/tags/Android-Studio/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://laocaixw.github.io/tags/Eclipse/"}]},{"title":"PopupWindow用法及源码浅析","date":"2017-02-22T11:40:00.000Z","path":"2017/02/22/PopupWindow用法及源码浅析/","text":"PopupWindow用法及源码浅析。转载请声明出处。 最近手头上的事比较多，博客也荒废了有三四个月，趁这几天任务稍微轻一点，也正好把这段时间学到的东西做个总结，对自己来说也是一种进步。 作为Android开发者一定对AlertDialog对话框很熟悉，与它类似的PopupWindow对于初学者来说可能接触得就比较少，但是PopupWindow也是常用的对话框控件之一。 1.用法PopupWindow的基本用法（PopupWindow的用法网上也有很多，想了解更多可以上网搜，这里只是写了个简单的）： 1234// 实例化，顾名思义，contentView就是要显示的内容，width和height就是宽和高PopupWindow popupWindow = new PopupWindow (contentView, width, height);// 显示PopupWindow，相对于父控件的位置popupWindow.showAtLocation(parent, gravity, x, y); 2.监听返回键大部分人可能需要让PopupWindow响应返回键，当PopupWindow显示的时候，按下返回键需要把PopupWindow关闭掉。 如果没有给PopupWindow设置焦点（即setFocusable(false);），那么我们就要在Activity的onBackPressed方法中关闭PopupWindow。如果给PopupWindow设置了焦点（即setFocusable(true);），这时候想要响应返回键，网上流传了一种方法，就是给PopupWindow设置背景。 为什么会这样呢？我们来看一下源码（这里是Android-19的源码），我们顺着showAtLocation()方法点进去，会看到preparePopup()方法，里面有这样一段代码： 12345678910111213141516171819if (mBackground != null) &#123; final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); int height = ViewGroup.LayoutParams.MATCH_PARENT; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; height = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; PopupViewContainer popupViewContainer = new PopupViewContainer(mContext); PopupViewContainer.LayoutParams listParams = new PopupViewContainer.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height ); popupViewContainer.setBackgroundDrawable(mBackground); popupViewContainer.addView(mContentView, listParams); mPopupView = popupViewContainer;&#125; else &#123; mPopupView = mContentView;&#125; 当给PopupWindow设置背景时，它会给contentView外面套上一个PopupViewContainer，这个PopupViewContainer是PopupWindow的一个内部类，它已经把返回键事件给消费掉了，并且还dismiss了PopupWindow，所以网上流传的这段代码说起来也是可行的。 3.Android 6.0之后的坑公司的项目里有一个加载框，就是用PopupWindow来实现的，但是公司做出来的效果是，当在请求网络数据时，显示这个加载框，并且不让用户做任何操作，只有请求结束后，才通过代码关闭这个加载框。那么可能有人就想到，不给它设焦点，然后在Activity的onBackPressed方法中拦截返回事件。抱歉，由于我们公司项目比较特别，我们的Activity管不到这个加载框，加载框是由服务端控制的。那么可能有人又想到，给它设焦点，然后不给它设置背景，bingo！我们公司就是这么做的。但是，当有人拿出6.0的手机时，按返回键莫名其妙就把PopupWindow给关掉了。这又是怎么回事呢？我们继续来看源码(这回是Android-23)。 12345678if (mBackground != null) &#123; mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground);&#125; else &#123; mBackgroundView = mContentView;&#125;mDecorView = createDecorView(mBackgroundView); 可以看到，无论是否设置了背景，最终都要createDecorView，这个createDecorView又是干什么的呢？继续往下看。 12345678910111213141516private PopupDecorView createDecorView(View contentView) &#123; final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; height = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; else &#123; height = ViewGroup.LayoutParams.MATCH_PARENT; &#125; final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView;&#125; 我们可以看到无论是否设置了背景，这边都会在外面套上一层PopupDecorView，而这个万恶的PopupDecorView竟然几乎就是6.0之前的那个PopupViewContainer，把PopupWindow关闭了还把我的返回键事件给消费掉了！ 4.结局万般无奈之下，只好将PopupWindow改为AlertDialog了！虽然改动了之后，影响的地方比较多，需要测试的也比较多，但是，加载框和AlertDialog还是更合适哦！","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"PopupWindow","slug":"PopupWindow","permalink":"http://laocaixw.github.io/tags/PopupWindow/"}]},{"title":"设计模式学习系列（1）--单例模式","date":"2016-11-07T14:13:03.000Z","path":"2016/11/07/设计模式学习系列（1）--单例模式/","text":"设计模式之单例模式。转载请声明出处。 单例模式：确保一个类只有一个实例存在，而且自行实例化并向整个系统提供这个实例。单例模式可以用在建立目录、数据库连接等需要单线程操作的场合，用于实现对系统资源的控制。 单例模式通常有两种：1.饿汉式：类加载时，就进行对象实例化。2.懒汉式：第一次引用类时，才进行对象实例化。 1. 饿汉式12345678910public class Singleton &#123; private static Singleton mInstance = new Singleton(); // 构造方法私有化，保证外界无法直接实例化 private Singleton() &#123; &#125; // 通过该方法获得实例对象 public static Singleton getInstance() &#123; return mInstance; &#125;&#125; 2. 懒汉式12345678910111213public class Singleton &#123; private static Singleton mInstance = null; // 构造方法私有化，保证外界无法直接实例化 private Singleton() &#123; &#125; // 方法同步，确保多线程环境下只创建一个实例 synchronized public static Singleton getInstance() &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; return mInstance; &#125;&#125; 在多线程开发中，往往需要使用synchronized关键字对代码进行同步，否则，可能在内存中生成两个实例，这样就违反了单例模式。 显然，饿汉式速度更快，而懒汉式更省内存。而实际上，饿汉式更符合 Java 语言本身特点。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Appium测试Android混合应用时,第二次切换到WebView时的定位问题","date":"2016-11-01T12:32:34.000Z","path":"2016/11/01/Appium测试Android混合应用时,第二次切换到WebView时的定位问题/","text":"Appium测试Android混合应用时，第二次切换到WebView时的定位问题。转载请声明出处。 在用Appium测试Android混合应用时，当程序第一次切换到WebView时，可以正常进行自动化测试。可是当程序第二次切换到WebView时，Appium会自动找到到第一次打开的Html页面，那么这时Appium就无法定位我们第二次打开的Html页面中的元素。 最近在做Android自动化测试开发，遇到了一个对我这种初学者来说非常棘手的难题，网上怎么找也找不到解决方案，不过最终还是被自己瞎猫碰到了死耗子~~在这里做个记录。废话就不多说，这里就直接提供我的解决方案。 解决方案:修改Appium源码Appium安装目录下的文件Appium\\node_modules\\appium\\lib\\devices\\android\\android-hybrid.js，文件中有这样一个函数： 123456789101112131415androidHybrid.startChromedriverProxy = function (context, cb) &#123; cb = _.once(cb); logger.debug(\"Connecting to chrome-backed webview\"); if (this.chromedriver !== null) &#123; return cb(new Error(\"We already have a chromedriver instance running\")); &#125; if (this.sessionChromedrivers[context]) &#123; // in the case where we've already set up a chromedriver for a context, // we want to reconnect to it, not create a whole new one this.setupExistingChromedriver(context, cb); &#125; else &#123; this.setupNewChromedriver(context, cb); &#125;&#125;; 改为： 12345678910111213141516androidHybrid.startChromedriverProxy = function (context, cb) &#123; cb = _.once(cb); logger.debug(\"Connecting to chrome-backed webview\"); if (this.chromedriver !== null) &#123; return cb(new Error(\"We already have a chromedriver instance running\")); &#125; // if (this.sessionChromedrivers[context]) &#123; // // in the case where we've already set up a chromedriver for a context, // // we want to reconnect to it, not create a whole new one // this.setupExistingChromedriver(context, cb); // &#125; else &#123; // this.setupNewChromedriver(context, cb); // &#125; this.setupNewChromedriver(context, cb);&#125;; Appium第一次切换到Html页面时，会新生成一个Chromedriver；当第二次切换到Html时，会使用已经存在的Chromedriver。但其实在我们的应用里面每次打开一个Activity时一般都是会重新创建一个WebChromeClient，所以这里就把它改成无论如何都生成一个新的Chromedriver。","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"Appium","slug":"Appium","permalink":"http://laocaixw.github.io/tags/Appium/"}]},{"title":"设计模式学习系列（0）--概述及设计原则","date":"2016-10-31T14:30:27.000Z","path":"2016/10/31/设计模式学习系列（0）--概述及设计原则/","text":"设计模式概述及设计原则。转载请声明出处。 先说概念： 设计模式是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。 Java 设计模式贯彻的原理是：面向接口编程，而不是面向现实。其目标原则是：降低耦合，增强灵活性。 通俗点来讲： 面向接口：举个例子，作为程序员，我们平时接触最多的就是电脑了，大部分人应该都有换过或加过内存条、硬盘等，为什么这些东西可以这么轻易更换呢？因为这些东西都是针对接口设计的。程序设计其实也是一样，如果那部分程序需要移植或出了问题，那么只要简单知道接口，就很容易办到了。 降低耦合：就是让模块之间的关系更少，当然也就是更容易接起来咯。把程序模块化，这样就易移植、易修改。 常用的设计模式总共有23种，可分为： 创建型：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式； 结构型：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式、亨元模式； 行为型：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介模式、观察者模式、备忘录模式、访问者模式、状态模式、解释器模式。 设计原则下面说下程序设计的几个原则。 1.单一职责原则一个类应当只有一个引起它变化的原因，即一个类应该只有一个职责。 单一职责原则就是为了降低耦合，让类与类之间不要有太多的牵制，看起来更简单，也可以让代码有更好的可读性，当然也就会更容易维护和扩展。 单一职责原则的优点可以概括为： 降低类的复杂性； 提高代码的可读性； 提高代码的可维护性和可复用性； 降低因变更引起的风险。 2.里式替换原则任何基类可以出现的地方，子类一定可以出现。 有些地方对这个原则说得非常啰嗦，其实这个原则就是为了让子类可以出现的地方尽量用父类来代替，这样可以是程序更容易扩展。 里式替换原则为良好的继承定义了一个规范： 子类必须完全实现父类的方法； 子类可以有自己的个性； 覆盖或实现父类的方法时输入参数可以被放大； 覆盖或实现父类的方法时输出结果可以被缩小。 有这样一句话写出来可能更好理解：按照里式替换原则，当多个类之间存在继承关系时，通常应该使用父类或接口来指向子类的对象（除非需要使用子类特有的方法），这更利于提高系统的可扩展性。 3.依赖倒置原则高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 (这里的抽象可以是抽象类或者接口) 依赖关系：A依赖B的意思是，如果A要完成某一操作，必须使用B的某些操作来帮忙，才能完成。简言之，B作为A的某个方法的方法参数存在。例如，汽车(B)能跑，司机(A)必须有汽车(B)开，才能算是司机，所以司机(A)依赖汽车(B)。 在项目中使用这个原则只要遵循以下几个规则： 每个类尽量都具有接口或者抽象类，或者两者都有，这是依赖倒置的基本要求； 变量的表面类型尽量是接口或者抽象类； 任何类都不应该从具体类派生； 尽量不要重写基类的方法； 结合里式替换原则使用：接口负责定义抽象方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。 这其实就可以算是“面向接口编程”，这里有一个例子可以参考，以便于更好理解。 4.接口隔离原则客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则跟单一职责原则有点像，一个是针对接口，一个是针对类，其实它们的思想是差不多的。我们在设计程序的时候，应该尽量去建立多个单一模块的接口，不要去建立一个臃肿庞大的接口。接口要尽量的细化，同时接口中的方法要尽量少。 其实无论是那个设计原则，都是为了让我们的程序更容易维护，更容易扩展。接口隔离也是一样，当要程序要引进新的功能时，不会对太多功能造成影响。 接口隔离原则需要注意的： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 5.迪米特法则迪米特法则又叫最少知识原则，意思是一个对象应当对其他对象尽可能少的了解。 只与你直接的朋友们通信，不要跟陌生人说话。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 举个简单的例子：如果A和B之间存在关联，B和C之间存在关联，A和C之间不存在关联，那么A要是想要调用C的方法，最好让A通过B去调用C的方法。 迪米特法则的好处就是，减少类之间的关联，降低类之间的耦合，使类的复用率更高。 迪米特法则还有一层意思，就是一个类应该尽量少的开发他们方法，能用protected和private的地方尽量不要用public。 6.开闭原则对扩展开放，对修改关闭。 开闭原则的重要性可以通过以下几方面来体现： 开闭原则提高可复用性。 开闭原则提高可维护性。 开闭原则提高灵活性。 开闭原则易于测试。 总的来说，无论什么设计原则，都是为了让程序更容易维护，更容易扩展。只要我们在设计程序的时候多想想是不是更容易维护，更容易扩展，是不是符合这些设计原则，我们就可以写出更好更健壮的代码。 UML类图学设计模式之前，应该先看看 UML 类图，这里有个很容易理解的例子。 另外，附上一个在线画图的工具： Process On 。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Android中NFC读取金融IC卡","date":"2016-09-21T13:15:10.000Z","path":"2016/09/21/Android中NFC读取金融IC卡/","text":"用有NFC功能的Android手机读取银行卡。转载请声明出处。 这篇文章具体分为以下几部分： Android中NFC的基本使用方法； NFC读取金融IC卡步骤； 读卡过程中涉及到的报文格式解析。 一、Android中NFC的基本使用方法NFC手机相比普通手机来说，有以下3个附加功能： 可以当成POS机来用，也就是“读取”模式 可以当成一张卡来刷，也就是NFC技术最核心的移动支付功能 可以像蓝牙、Wi-Fi一样做点对点通信 这里要说的就是第一种，”读卡” ! 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class NFCActivity extends Activity &#123; private NfcAdapter mNfcAdapter = null; private PendingIntent mPendingIntent = null; private IntentFilter[] mIntentFilter = null; private String[][] mTechList = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.acitivity_nfc); nfcCheck(); mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0); // 过滤器总共有三种 IntentFilter intentFilter1 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); IntentFilter intentFilter2 = new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED); IntentFilter intentFilter3 = new IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED); mIntentFilter = new IntentFilter[]&#123;intentFilter1, intentFilter2, intentFilter3&#125;; // 只针对ACTION_TECH_DISCOVERED mTechList = new String[][]&#123; &#123;IsoDep.class.getName()&#125;, &#123;NfcA.class.getName()&#125;, &#123;NfcB.class.getName()&#125;, &#123;NfcV.class.getName()&#125;, &#123;NfcF.class.getName()&#125;, &#123;Ndef.class.getName()&#125;&#125;; &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Log.i(\"MyLog\", \"Tag:\" + intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)); IsoDep isoDep = IsoDep.get((Tag) intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)); try &#123; isoDep.connect(); byte[] payload = stringToBytes(\"00A404000E315041592E5359532E4444463031\"); // 将字符串转为byte数组 byte[] data = isoDep.transceive(payload); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, mIntentFilter, mTechList); &#125; @Override protected void onPause() &#123; super.onPause(); mNfcAdapter.disableForegroundDispatch(this); &#125; private void nfcCheck() &#123; mNfcAdapter = NfcAdapter.getDefaultAdapter(this); if (mNfcAdapter == null) &#123; Toast.makeText(this, \"本机不支持NFC\", Toast.LENGTH_SHORT).show(); finish(); return; &#125; else &#123; if (!mNfcAdapter.isEnabled()) &#123; // NFC未打开 Intent setNfc = new Intent(Settings.ACTION_NFC_SETTINGS); startActivity(setNfc); &#125; &#125; &#125; public byte[] stringToBytes(String s) &#123; int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) &#123; data[(i / 2)] = ((byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character .digit(s.charAt(i + 1), 16))); &#125; return data; &#125; public String bytesToString(byte[] data) &#123; String temp = \"\"; for (byte d : data) &#123; temp += String.format(\"%02X\", d); &#125; return temp; &#125; &#125; 这里在nfcCheck()方法中检查手机是否支持NFC功能和NFC是否开启，NfcAdapter就是手机的NFC适配器。 12mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, mIntentFilter, mTechList);mNfcAdapter.disableForegroundDispatch(this); 在onResume()和onPause()方法中，这两个方法分别表示前台读取Tag（就是指卡片）的开关。一旦手机检测到卡片，onNewIntent(Intent intent)方法就会执行。 IsoDep可以看做一个与卡片通信的工具类。intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)就是表示Tag（卡片）；isoDep.connect()就是手机NFC与卡片连接；isoDep.transceive(payload)就是向卡片发送报文，它的返回数据就是卡片的响应报文，这里都是通过byte数组通信的。 二、NFC读取金融IC卡步骤具体的读卡步骤可以参考《中国金融集成电路（IC）卡规范》、《中国银联IC卡技术规范》等，这边简化如下，有兴趣的可以自己往上加： 应用选择； 应用初始化； 读应用数据； 生成应用密文。 1.应用选择 说明: 这里图片内容大多来自《中国金融集成电路（IC）卡规范》，建议参考。 终端接收到卡片发来的数据大多数都是TLV格式的数据，TLV格式数据详解见本文第三部分，建议先理解TLV格式后再继续往下看。 下文命令都以16进制表示。 9000为响应成功状态码。 (1) 使用SELECT命令选择文件:1PAY.SYS.DDF01 即命令为：00-A4-04-00-0E-315041592E5359532E4444463031 发送：00A404000E315041592E5359532E4444463031 接收：6F1E840E315041592E5359532E4444463031A50C8801015F2D027A689F1101019000 从接收到的数据中，按TLV格式解析，可以得到SFI(88)为01，下一步需要用到。 (2) 根据SFI发送读记录READ RECORD命令 SFI为01，即 0000 0001 ，低三位为 100 ，所以引用控制参数P2为 00001 100 ，即 0C 。所以读记录命令为：00-B2-01-0C-00 发送：00B2010C00 接收：702861264F08A000000333010101500A50424F432044454249548701019F120A50424F432044454249549000 同样，按TLV格式解析，得到应用标识符AID(4F)为A000000333010101 (3) 根据AID选择应用发送：00A4040008A000000333010101 接收：6F548408A000000333010101A548500A50424F432044454249548701019F38189F66049F02069F03069F1A0295055F2A029A039C019F37045F2D027A689F1101019F120A50424F43204445424954BF0C059F4D020B0A9000 按TLV格式解析，得到PDOL的数据(9F38)为9F66049F02069F03069F1A0295055F2A029A039C019F3704。这里的PDOL数据不是TLV，只有命令部分类似TLV，PDOL数据为多条“命令+长度”组合而成。分解如下： 命令:长度 –名称 9F66:04 –终端交易属性 9F02:06 –授权金额,消费金额 9F03:06 –其它金额，目前还没有定义 9F1A:02 –终端国家代码,中国：0156 95:05 –终端验证结果 5F2A:02 –交易货币代码 9A:03 –交易日期 9C:01 –交易类型 9F37:04 –不可预知数,最好去随机数 2.应用初始化(1) 获取处理选项 根据上一步得到的PDOL数据，按照顺序发送GET PROCESSING OPTIONS命令。80-A8-00-00-23-83-21-40800000-000000000000-000000000000-0156-0000000000-0156-160913-99-4D23571A。83表示GPO数据。 发送：80A8000023832140800000000000000000000000000000015600000000000156160913994D23571A 接收：80127C00080101001001030118010300200101009000 响应分解：80-12-7C00-08010100-10010301-18010300-20010100-9000 7C00为AIP，后面每4个字节为一个AFL。 以10010301为例： 10 即 0001 0000 ，前五位为SFI； 01 表示第一条要读的记录； 03 表示最后一条要读的记录； 01 表示从第一个记录开始的用于脱机数据认证的连续记录数 3.读应用数据根据上一步返回的AFL逐条读取应用数据，即逐条发送读记录命令：00B2010C00；00B2011400，00B2021400，00B2031400；00B2011C00，00B2021C00，00B2031C00；00B2012400。返回的数据都是TLV格式的报文，把每次读记录得到的响应解析出来，应用数据包括卡号什么的都在里面了。在返回的数据中包括了一个CDOL1(8C)数据:9F02069F03069F1A0295055F2A029A039C019F37049F21039F4E14，这个跟前文中的PDOL数据类似。 命令:长度 9F02:06 9F03:06 9F1A:02 95:05 5F2A:02 9A:03 9C:01 9F37:04 9F21:03 9F4E:14 4.生成应用密文根据上一步得到的CDOL1，发送GENERATE AC命令，来生成应用密文。 这里要生成一个ARQC密文，80-AE-80-00-34-000000000000000000000000015600000000000156160913994D23571A000000000000000000000000000000000000000000000000 发送：80AE800034000000000000000000000000015600000000000156160913994D23571A000000000000000000000000000000000000000000000000 接收：801E8000750317DB9AEDE4DD5607010103A0A000010A010000000000890C15B29000 按TLV格式解析，得到一个80数据：8000750317DB9AEDE4DD5607010103A0A000010A010000000000890C15B2 分解如下：80-0075-0317DB9AEDE4DD56-07010103A0A000010A010000000000890C15B2 应用交易计数器:0075 应用密文:0317DB9AEDE4DD56 发卡行应用数据:07010103A0A000010A010000000000890C15B2 三、读卡过程中涉及到的报文格式解析1.TLV格式解析TLV就是 Tag + Length + Value 。Tag是标识，Length是后面数据值Value的长度。TLV数据可以有复合数据，即一个TLV中的Value还可以包含一个或多个TLV。 (1) TagTag最多可以占两个字节，编码规则如下： 第一图表示第一个字节的编码规则，b6决定当前的TLV数据是单一结构的数据或者复合结构的数据。b5-b1如果全为1，则这个Tag占两个字节，否则只占一个字节。 如果Tag占两个字节，则第二图表示第二个字节的编码规则。 b8决定Tag是否还有后绪的字节存在，因为PBOC/EMV里的Tag最多占两个字节, 所以该位保持为0。 所以： 123456789101112if ((tlvData[i] &amp; 0x20) != 0x20) &#123; // 单一结构 if ((tlvData[i] &amp; 0x1F) == 0x1F) &#123; // tag两字节 tagIndex++; // 解析length域 // 解析value域 &#125; else &#123; // tag单字节 // 解析length域 // 解析value域 &#125;&#125; else &#123; // 复合结构 // 复合结构可以考虑用递归的方法来实现.&#125; (2) LengthLength最多可以有四个字节。如果第一个字节的最高位b8为0，b7-b1的值就是value域的长度；如果b8为1，b7-b1的值就表示了下面有几个子字节，下面子字节的值就是value域的长度。 (3) ValueValue的编码格式要根据具体Value所表示的数据元决定，有可能还是TLV格式的数据，也有可能是其他数据。 引用最后，感谢以下博客的博主： http://blog.csdn.net/lvxiangan/article/details/17218409 http://blog.csdn.net/kxd_ysheng/article/details/21178101 http://blog.csdn.net/kxd_ysheng/article/details/21237957 http://blog.csdn.net/artmcu/article/details/8086153 http://blog.chinaunix.net/uid-20551291-id-3340818.html http://blog.sina.com.cn/s/blog_625033800101f5cm.html http://blog.sina.com.cn/s/blog_a20257d80101n17j.html","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://laocaixw.github.io/tags/NFC/"},{"name":"金融IC卡","slug":"金融IC卡","permalink":"http://laocaixw.github.io/tags/金融IC卡/"}]},{"title":"Volley的用法","date":"2016-07-28T04:47:01.000Z","path":"2016/07/28/Volley的用法/","text":"Android网络通信框架Volley的用法。转载请声明出处。 Volley是谷歌官方推出的一个Android网络通信框架库，既可以做普通的网络请求，又可以做图片的异步加载和缓存处理，适用于通信频繁的网络操作。如果是加载的图片较多，不建议用Volley的本地缓存，因为经本人测试，如果缓存图片较多，Volley加载本地缓存的速度非常慢。参考：郭霖的博客。 1.下载Volley1git clone https://android.googlesource.com/platform/frameworks/volley 2.Volley的用法 1.获取一个请求队列； 2.创建一个请求对象； 3.将请求对象加到请求队列中。 Volley的请求对象有：StringRequest、JsonRequest、ImageRequest，对于图片还有ImageLoader、NetworkImageView，另外还可以定制自己的Request。 简单的StringRequest请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);StringRequest stringRequest = new StringRequest(url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; Log.d(\"TAG\", response); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;);mQueue.add(stringRequest); 简单的JsonRequest请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(rul, null, new Response.Listener&lt;JSONObject&gt;() &#123; @Override public void onResponse(JSONObject response) &#123; Log.d(\"TAG\", response.toString()); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;);mQueue.add(jsonObjectRequest); 简单的ImageRequest请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);ImageRequest imageRequest = new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; imageView.setImageBitmap(response); &#125; &#125;, 0, 0, Config.RGB_565, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; imageView.setImageResource(R.drawable.default_image); &#125; &#125;);mQueue.add(imageRequest); ImageLoader的用法12345678910111213141516RequestQueue mQueue = Volley.newRequestQueue(context);ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() &#123; //本地缓存 @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; return null; &#125;&#125;);ImageListener listener = ImageLoader.getImageListener(imageView, R.drawable.default_image, R.drawable.failed_image);imageLoader.get(imageUrl, listener);//imageLoader.get(imageUrl, listener, 200, 200); // 指定图片允许的最大宽度和高度 这里可以根据个人需要加入LruCache做个内存缓存。 NetworkImageView的用法NetworkImageView是一个继承自ImageView的控件，ImageView有的属性它基本都有。 在布局中添加控件： 123456&lt;com.android.volley.toolbox.NetworkImageView android:id=\"@+id/network_image_view\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_gravity=\"center_horizontal\" /&gt; 用法： 1234567891011121314151617networkImageView = (NetworkImageView) findViewById(R.id.network_image_view);networkImageView.setDefaultImageResId(R.drawable.default_image);networkImageView.setErrorImageResId(R.drawable.failed_image);RequestQueue mQueue = Volley.newRequestQueue(context);ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() &#123; //本地缓存 @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; return null; &#125;&#125;);networkImageView.setImageUrl(imageUrl, imageLoader); 自定义Request可以参考StringRequest源码，自定义XMLRequest： 1234567891011121314151617181920212223242526272829303132public class XMLRequest extends Request&lt;XmlPullParser&gt; &#123; private final Listener&lt;XmlPullParser&gt; mListener; public XMLRequest(int method, String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; // 带请求方式的构造函数 super(method, url, errorListener); mListener = listener; &#125; public XMLRequest(String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; // 不带请求方式的构造函数 this(Method.GET, url, listener, errorListener); &#125; @Override protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) &#123; // 获取响应后通过此函数得到一个XmlPullParser的响应 try &#123; String xmlString = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlString)); return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (XmlPullParserException e) &#123; return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(XmlPullParser response) &#123; mListener.onResponse(response); &#125;&#125; 使用自定义的XMLRequest： 123456789101112131415RequestQueue mQueue = Volley.newRequestQueue(context);XMLRequest xmlRequest = new XMLRequest(url, new Response.Listener&lt;XmlPullParser&gt;() &#123; @Override public void onResponse(XmlPullParser response) &#123; // 在此对得到的XmlPullParser响应做处理 &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;); mQueue.add(xmlRequest); 3.Volley源码分析官方图解： 估计也就只有我能看懂的图解分析： 总的来说，volley是开了一个缓存线程和四个网络线程，当一个请求被加到队列中后，会先查看是否有缓存，如果有缓存那么走缓存线程读取缓存数据，如果没有则将请求加入到网络线程队列，读取网络数据。","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://laocaixw.github.io/tags/Volley/"}]},{"title":"Android Studio上的NDK开发","date":"2016-07-25T16:22:41.000Z","path":"2016/07/26/Android Studio上的NDK开发/","text":"在Android Studio上用C/C++开发Android。转载请声明出处。 Android的NDK开发，也可以称为Android的JNI开发。NDK是一系列工具，JNI是一种技术或者说是一种协议。 刚刚学了Android的NDK开发，但是教程是基于Eclipse的，为了赶上节奏，马不停蹄的在Android Studio上做实验，鼓捣了半天，也踩了不少坑，就这里做个记录！ 首先是自己的各种版本，基本都是目前最新的：Android Studio 2.1.2，NDK 12.1，gradle 2.1.2。 万万没想到，这是我踩最大的坑：文件夹命名不要带空格！ 1.给项目gradle.properties加上以下代码，表示要用NDK了： 1android.useDeprecatedNdk=true 2.在local.properties中加入ndk和sdk的路径： 12ndk.dir=D\\:\\\\work\\\\Android\\\\sdk\\\\ndk-bundlesdk.dir=D\\:\\\\work\\\\Android\\\\sdk 3.在app文件夹下的build.gradle中的defaultConfig里加入： 1234ndk&#123; moduleName \"NDKTest\" abiFilters \"armeabi\",\"x86\" &#125; 其中moduleName指要生成的.so文件名称，这个要记住，后面还会用到。abiFilters指要生成哪几个平台的so文件。 4.新建一个Java类，要通过这个类来调用C/C++的代码： 123456public class GetString &#123; static &#123; System.loadLibrary(\"NDKTest\");//导入生成的链接库文件 &#125; public static native String getStr();&#125; 其中用native修饰的方法，就是要在C/C++中实现的方法，System.loadLibrary(“NDKTest”)是表示要调用”NDKTest”这个so文件，就是3中的moduleName。 5.在\\app\\src\\main\\中新建jni目录（右键-&gt;new-&gt;Folder-&gt;JNI Folder）。然后编译（Build-&gt;Make Project）生成.class文件，这里主要是要得到GetString.class这个类。生成的class文件在工程的\\app\\build\\intermediates\\classes\\debug\\里。用Terminal命令行工具cd进入此文件夹，输入以下命令生成头文件： 1javah -d ../../../../src/main/jni/ -jni com.laocaixw.ndktest.GetString 这里说明一下： javah ——是要将java类输出为C/C++的.h头文件。 -d ../../../../src/main/jni/ ——这段表示文件输出的位置，这里../表示返回上层目录，这样写是什么意思应该就能理解了，表示输出到\\app\\src\\main\\jni\\里。 -jni com.laocaixw.ndktest.GetString ——这里-jni就是jni的命令咯，com.laocaixw.ndktest.GetString就是指当前目录下的com.laocaixw.ndktest.GetString这个类。 6.执行完以上命令后，会在\\app\\src\\main\\jni\\下生成”com_laocaixw_ndktest_GetString.h”文件，里面应该有一个类似这样的函数： 12JNIEXPORT jstring JNICALL Java_com_laocaixw_ndk_GetString_getStr (JNIEnv *, jclass); 7.在\\app\\src\\main\\jni\\里新建一个C/C++文件.cpp，将6中的头文件引入，并把上述函数复制进来，做以下修改： 123456#include \"com_laocaixw_ndktest_GetString.h\"JNIEXPORT jstring JNICALL Java_com_laocaixw_ndk_GetString_getStr (JNIEnv *env, jclass) &#123; return env-&gt;NewStringUTF(\"Hello NDK\"); &#125; 这里表示，当java中调用GetString.getStr()时，会调用C/C++中的上述这个函数，然后返回”Hello NDK”。 8.最后Make Project一下，看是不是在\\app\\build\\intermediates\\ndk\\debug\\下生成了so文件，如果是，那么应该大功告成，可以运行了。 9.最后，编译运行前，别忘了把打开了\\app\\build\\intermediates\\classes\\debug\\的Terminal命令行工具关掉，否则占用这个文件夹会导致编译不成功。因为编译的时候，会把build里的东西全部删除再重新生成，如果占用的话，删除不了就会出错。","tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://laocaixw.github.io/tags/NDK/"},{"name":"JNI","slug":"JNI","permalink":"http://laocaixw.github.io/tags/JNI/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://laocaixw.github.io/tags/Android-Studio/"}]},{"title":"Git的科学上网方式","date":"2016-07-03T08:18:28.000Z","path":"2016/07/03/Git的科学上网方式/","text":"Git Bash的科学上网方式。转载请声明出处。 最近从CSDN博客上学习了Android的网络开源库Volley的一些基本用法（郭大神的博客），volley是谷歌推出的，想要下载它的话当然得用科学的上网方式了。虽然从网上也可以下载到已经打包好的volley.jar，但是还是想自己从官网克隆下来，因为谁知道网上下载的纯不纯呢。 于是，从网上各种搜索，再自己各种测试，终于功夫不负有心人！于是把方法记录下来。 因为我平时科学上网没有买代理，用的是一个免费的软件赛风，一键上网，虽然速度慢，而且不稳定，但是可以用。如果你也是用的赛风，那你就可以看看我的教程。 首先你要了解git设置代理服务器和恢复默认的方法： 1.设置代理服务器： 1git config --global http.proxy http://proxyuser:proxypwd@proxy.server.com:8080 1git config --global https.proxy https://proxyuser:proxypwd@proxy.server.com:8080 proxyuser:代理服务器用户 proxypwd:密码 proxy.server.com：代理服务器地址 8080：代理服务器端口号 2.重设代理，恢复默认： 1git config --global --unset http.proxy 1git config --global --unset https.proxy 下面开始修改： 1.设置赛风本地代理端口： 2.修改Git配置： 1git config --global http.proxy http://127.0.0.1:12345 1git config --global https.proxy https://127.0.0.1:12345 3.将代码克隆到本地成功后，恢复Git默认配置： 1git config --global --unset http.proxy 1git config --global --unset https.proxy","tags":[{"name":"Git","slug":"Git","permalink":"http://laocaixw.github.io/tags/Git/"},{"name":"科学上网","slug":"科学上网","permalink":"http://laocaixw.github.io/tags/科学上网/"}]},{"title":"GitHub搭建个人博客(hexo)","date":"2016-06-08T04:13:00.000Z","path":"2016/06/08/GitHub搭建个人博客-hexo/","text":"用hexo在GitHub上搭建静态个人博客。转载请声明出处。 参考使用hexo与github搭建静态博客，并结合自己的理解完成。本文适用于Window。 前段时间学完 Android第一行代码 后，想着用GitHub搭建一个个人博客，这两天终于有时间来研究了。其实自己对这方面一直都没有什么头绪，从网上各种查阅资料，终于有了点理解，也成功搭建了自己的博客，虽然有点粗糙，但是对初学者来说，入门应该是没什么问题了。 废话不多说，直接进入正题： 一.选择搭建工具目前大家用来搭建静态博客的工具，比较流行的应该就是jekyll和hexo。据我了解jekyll可以把原文直接上传到GitHub上，但是好像得自己编写html文件；而hexo是在本地先写好md文件，然后自动直接生成一堆静态网页的东西(代码库)，最后上传到GitHub上就可以了。貌似GitHub官方是推荐jekyll。总之，我感觉网上更多人说hexo好用，所以我也选择了hexo。 在GitHub上搭建hexo静态网页需要具备以下技能： 1.GitHub。代码托管，既然能看到这篇文章，GitHub基础应该都会了，不会也没关系，知道就行。 2.MarkDown。程序员最爱的写文章的东西，虽然我也不是很会，不过大家可以参考CSDN的编辑模板。 3.yaml。“另一种标记语言”。什么鬼名字，应该跟XML、JSON这些差不多吧，这个理解一点就行了，我也是现学现卖，可以先跳过。 二.安装1.安装Git。GitHub的本地工具。下载安装就行了。 2.安装Node.js。安装hexo的必要条件，我也不知道是什么，反正也是先下载安装就行了。 3.安装hexo。重点来了，这个hexo是生成静态网页代码库的核心工具。 1.新建hexo文件夹，用于存放hexo相关文件，以我自己的为例：新建文件夹为D:\\work\\hexo，后面都以此为例。 2.打开CMD命令，进入hexo文件夹（不懂的最好自己百度怎么进）。教大家一个简便方法，打开D:\\work\\hexo文件夹，在上方地址栏中直接输入cmd，然后回车。 3.输入以下命令安装hexo： 1npm install -g hexo 4.输入以下命令自动生成建立网站所需文件，其中blog表示在D:\\work\\hexo下新建blog文件夹，并且生成的文件在D:\\work\\hexo\\blog中： 1hexo init blog 5.进入blog文件夹： 1cd blog 6.安装node_modules： 1npm install 至此，hexo安装完毕。 三.启动本地服务和新建文章 1.在D:\\work\\hexo\\blog目录下，输入以下命令启动本地hexo服务： 1hexo server 在浏览器中输入 http://localhost:4000/ 可以进行预览，可以看到一篇hexo默认自动生成的文章，里面介绍了一些hexo的命令。按Ctrl+C停止服务。 2.在默认的文章中也可以看到，新建一篇博客的命令为： 1hexo new \"文章标题\" 执行该命令后，文章会在D:\\work\\hexo\\blog\\source_posts中生成，当然是md格式了。 hexo首页默认显示的是文章全文，如果你想只显示文章的简介，就在文章中你想在首页显示的部分后加上: 1&lt;!--more--&gt; 四.更换主题好了，写完文章你可能感觉这个主题看着不是很顺眼，必须换一个主题啊，不然怎么符合自己的身份呢。我是用的yilia主题，下面就以此为例讲解。 1.克隆主题到本地。在D:\\work\\hexo\\blog目录下，右键打开Git Bash（只要你正常安装了Git后就会有），输入以下命令： 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia （此条命令表示，克隆https://github.com/litten/hexo-theme-yilia.git 代码库到当前目录的themes/yilia文件夹下）执行完后你会发现，在你的D:\\work\\hexo\\blog目录下的themes文件夹里，生成了一个yilia文件夹，这里面就存放着你克隆下来的新主题。一般开源主题的README.md文件都会介绍主题怎么用，可以看一下。 2.修改主题。在你的D:\\work\\hexo\\blog目录下有一个_config.yml文件，修改里面的theme关键字为yilia，一般默认是theme: landscape，改为theme: yilia就行了。怎么改？用自带的文本编辑器就行了，但是建议最好给自己电脑上安装一个差不多的编辑器，我用的是UltraEdit。 好了，现在可以在打开服务器（别告诉我你忘了，这个真不能忘：hexo server），输入 http://localhost:4000/ 进行预览了，主题是不是变了？大功告成！ 学会了修改主题，现在就可以去找个自己喜欢的主题了。可以在这里面找一个，也可以去hexo官网找一个（官网主题的GitHub地址，一般在主题预览页面的犄角旮旯里，认真找一下都能找到）。 五.生成网站并部署到GitHub上现在是不是觉得自己牛逼了，可以写文章了，还可以在浏览器上看。但是，别急你做的这些都是在本地，别人可看不到你的文章。 1.新建GitHub代码库。进入你的GitHub主页，点击右上角的加号，选择New repository；命名为XXX.github.io ，XXX输你自己的id吧，以后这个就是你的网站了，必须以这个格式来命名；填下Description描述，勾选Initialize this repository with a README，点击绿色按钮Create repository完成代码库的创建。现在你的代码库只有一个README.md文件。 2.克隆GitHub代码库到本地（前面说过了哦）适当的位置，可以在你的代码库主页上点击绿色按钮Clone or download，再点右边的小箭头就可以复制代码库地址。以我的为例，GitHub代码库地址为 https://github.com/laocaixw/laocaixw.github.io.git ，在D:\\work\\hexo下右键打开Git Bash，输入（这里注意，可不要把我的GitHub地址输进去了~~~）： 1git clone https://github.com/laocaixw/laocaixw.github.io.git github/myblog 现在，D:\\work\\hexo\\github\\myblog文件夹下就是你从GitHub上拷贝下来的代码库了，这个时候里面只有一个.git的隐藏文件夹和一个README.md文件。 3.自动生成网站。在刚才的D:\\work\\hexo\\blog下运行CMD命令： 1hexo generate 这条命令输hexo g也可以，每次你在D:\\work\\hexo\\blog\\source_posts下写完一篇md文章后，都要用这条命令来自动生成网站代码，以后会经常用哦。好，这样，你的网站的代码库就自动生成了，在哪里呢？在D:\\work\\hexo\\blog\\public文件夹里。复制里面的所有东西，粘贴到刚才的D:\\work\\hexo\\github\\myblog中，再在D:\\work\\hexo\\github\\myblog中运行Git Bash上传你的代码： 因为你复制进去后，还没提交到Git里。添加所有代码（注意有个点）： 1git add . 提交你的添加，备注填本次提交的信息，以供以后参考： 1git commit -m &quot;备注&quot; 上传到GitHub上： 1git push origin master 然后输入账号密码，等待一会儿。 现在看看你的GitHub里的东西，是不是变多了？ 好，你的网站搭建成功了，不信你上去 http://laocaixw.github.io/ 看看。 六.404网页你还可以给自己自定义一个404网页，一旦访问你的网站的某个页面不存在时，就会跳到404网页。网上也有很多模板可以用，如：腾讯的寻子公益404页面。 在D:\\work\\hexo\\blog\\source下新建一个404.html文件，把以下代码复制进去： &lt;script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://yoursite.com/yourPage.html\" homePageName=\"回到我的主页\"&gt;&lt;/script&gt; 修改“homePageUrl”、“homePageName”两个参数即可。","tags":[{"name":"Blog","slug":"Blog","permalink":"http://laocaixw.github.io/tags/Blog/"},{"name":"GitHub","slug":"GitHub","permalink":"http://laocaixw.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://laocaixw.github.io/tags/Hexo/"}]},{"title":"KMP算法的个人理解","date":"2016-05-06T13:14:00.000Z","path":"2016/05/06/KMP算法的个人理解/","text":"KMP算法。转载请声明出处。 自学了一段时间，刚刚准备转行做软件开发，面试过程中被指出计算机基础知识薄弱。因为是非科班出生，确实有些计算机方面的基础没有学过，也开始恶补这些方面的东西。最近在学习数据结构与算法过程中，学到KMP算法，甚是难解。看了阮一峰的网络日志后才慢慢理解，但也发现其中的瑕疵，在此也顺带指出，至于对或不对，还请各位看客指正。 图片和例子讲解均引自阮一峰的网络日志，稍作修改，侵改。 正文举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”，即字符串”ABCDABD”是否是字符串”BBC ABCDAB ABCDABCDABDE”的子串。 定义 字符串1：”BBC ABCDAB ABCDABCDABDE”(包含空格) 搜索词2：”ABCDABD” 普通的字符串匹配算法将搜索词2中的第一位“A”，与字符串1中的第一位“B”匹配，若不匹配，则与字符串1中的第二位“B”匹配 … 直到匹配到第五位“A”，可匹配。 将搜索词2中的第二位“B”，与字符串1中的第六位“B”匹配，可匹配，则继续进行后面的字符匹配。 直到搜索词2与字符串1的某段完全匹配，则可认为搜索词2是字符串1的子串。 这种方法简单粗暴，但效率极低。 KMP算法1.首先，字符串1的第一个字符与搜索词2的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。 2.因为B与A不匹配，搜索词再往后移。 3.就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。 4.接着比较字符串和搜索词的下一个字符，还是相同。 5.直到字符串有一个字符，与搜索词对应的字符不相同为止。 6.这时，普通的字符串匹配算法是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 7.一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 8.怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。 9.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已经匹配对的字符数 - 最后一个匹配对的部分匹配值 + 当前匹配错的部分匹配值 因为 6 - 2 + 0 等于4，所以将搜索词向后移动4位。 10.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0 + 0，结果为 2，于是将搜索词向后移2位。 11.因为空格与A不匹配，继续后移一位。 12.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2 + 0，继续将搜索词向后移动4位。 13.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。 部分匹配表下面介绍 部分匹配表 是如何产生的 “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 “部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 如果大家有兴趣可以用以下两组数进行匹配，就会发现一个不一样的过程： 字符串：ABCABDABCABC 搜索词：ABCABC","tags":[{"name":"算法","slug":"算法","permalink":"http://laocaixw.github.io/tags/算法/"}]}]